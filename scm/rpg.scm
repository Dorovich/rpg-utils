(define (string-split char-delimiter? string)
  (define (maybe-add a b parts)
    (if (= a b)
      parts
      (cons (substring string a b) parts)))
  (let ((n (string-length string)))
    (let loop ((a 0) (b 0) (parts '()))
      (if (< b n)
	(if (not (char-delimiter? (string-ref string b)))
	  (loop a (+ b 1) parts)
	  (loop (+ b 1) (+ b 1) (maybe-add a b parts)))
	(reverse (maybe-add a b parts))))))

(define (is-d? char)
  (eq? char 'd'))

(define (rpg/roll expr)
  (write expr)
  (newline)
  (let* ((nums (string-split is-d? (car expr)))
	 (shart (write nums))
	 (times (string->number (car nums)))
	 (faces (string->number (cadr nums)))
	 (result 0))
    (set! *random-state* (random-state-from-platform))
    (do ((i 1 (1+ i)))
      ((> i times))
      (1+ result))
    (format #t "~dd~d => ~d~%" times faces result)))

;(define valid-commands '(("repl" . rpg/repl-startup)
;			 ("roll" . rpg/roll)
;			 ("coin" . rpg/coin)
;			 ("info" . rpg/info)
;			 ("new" . rpg/new)
;			 ("do" . rpg/do)))

(define valid-commands `(("roll" . ,rpg/roll)))

(define (main args)
  (when (null? args)
    (format #t "Iniciando REPL...~%")
    ;(rpg/repl-startup)
    (values #f))
  (let* ((cmd (cadr args))
	 (f (assoc-ref valid-commands cmd)))
    (if (procedure? f)
      (f (cddr args))
      (format #t "[!] El comando ~a no existe.~%" cmd))))
